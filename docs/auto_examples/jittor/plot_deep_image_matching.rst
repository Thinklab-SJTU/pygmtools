
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "auto_examples/jittor/plot_deep_image_matching.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        Click :ref:`here <sphx_glr_download_auto_examples_jittor_plot_deep_image_matching.py>`
        to download the full example code

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_auto_examples_jittor_plot_deep_image_matching.py:


==========================================================
Matching Image Keypoints by Graph Matching Neural Networks
==========================================================

This example shows how to match image keypoints by neural network-based graph matching solvers.
These graph matching solvers are designed to match two individual graphs. The matched images
can be further passed to tackle downstream tasks.

.. GENERATED FROM PYTHON SOURCE LINES 11-17

.. code-block:: default


    # Author: Runzhong Wang <runzhong.wang@sjtu.edu.cn>
    #         Wenzheng Pan <pwz1121@sjtu.edu.cn>
    #
    # License: Mulan PSL v2 License








.. GENERATED FROM PYTHON SOURCE LINES 19-28

.. note::
    The following solvers are based on matching two individual graphs, and are included in this example:

    * :func:`~pygmtools.neural_solvers.pca_gm` (neural network solver)

    * :func:`~pygmtools.neural_solvers.ipca_gm` (neural network solver)

    * :func:`~pygmtools.neural_solvers.cie` (neural network solver)


.. GENERATED FROM PYTHON SOURCE LINES 28-42

.. code-block:: default

    import jittor as jt # jittor backend
    from jittor import Var, models, nn
    import pygmtools as pygm
    import matplotlib.pyplot as plt # for plotting
    from matplotlib.patches import ConnectionPatch # for plotting matching result
    import scipy.io as sio # for loading .mat file
    import scipy.spatial as spa # for Delaunay triangulation
    from sklearn.decomposition import PCA as PCAdimReduc
    import itertools
    import numpy as np
    from PIL import Image
    pygm.BACKEND = 'jittor' # set default backend for pygmtools
    jt.flags.use_cuda = jt.has_cuda








.. GENERATED FROM PYTHON SOURCE LINES 43-55

Predicting Matching by Graph Matching Neural Networks
------------------------------------------------------
In this section we show how to do predictions (inference) by graph matching neural networks.
Let's take PCA-GM (:func:`~pygmtools.neural_solvers.pca_gm`) as an example.

Load the images
^^^^^^^^^^^^^^^^
Images are from the Willow Object Class dataset (this dataset also available with the Benchmark of ``pygmtools``,
see :class:`~pygmtools.dataset.WillowObject`).

The images are resized to 256x256.


.. GENERATED FROM PYTHON SOURCE LINES 55-69

.. code-block:: default

    obj_resize = (256, 256)
    img1 = Image.open('../data/willow_duck_0001.png')
    img2 = Image.open('../data/willow_duck_0002.png')
    kpts1 = jt.Var(sio.loadmat('../data/willow_duck_0001.mat')['pts_coord'])
    kpts2 = jt.Var(sio.loadmat('../data/willow_duck_0002.mat')['pts_coord'])
    kpts1[0] = kpts1[0] * obj_resize[0] / img1.size[0]
    kpts1[1] = kpts1[1] * obj_resize[1] / img1.size[1]
    kpts2[0] = kpts2[0] * obj_resize[0] / img2.size[0]
    kpts2[1] = kpts2[1] * obj_resize[1] / img2.size[1]
    img1 = img1.resize(obj_resize, resample=Image.BILINEAR)
    img2 = img2.resize(obj_resize, resample=Image.BILINEAR)
    jittor_img1 = jt.Var(np.array(img1, dtype=np.float32) / 256).permute(2, 0, 1).unsqueeze(0) # shape: BxCxHxW
    jittor_img2 = jt.Var(np.array(img2, dtype=np.float32) / 256).permute(2, 0, 1).unsqueeze(0) # shape: BxCxHxW





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    /mnt/c/Users/liber/OneDrive/Documents/2022/pygmtools/examples/jittor/plot_deep_image_matching.py:64: DeprecationWarning: BILINEAR is deprecated and will be removed in Pillow 10 (2023-07-01). Use Resampling.BILINEAR instead.
      img1 = img1.resize(obj_resize, resample=Image.BILINEAR)
    /mnt/c/Users/liber/OneDrive/Documents/2022/pygmtools/examples/jittor/plot_deep_image_matching.py:65: DeprecationWarning: BILINEAR is deprecated and will be removed in Pillow 10 (2023-07-01). Use Resampling.BILINEAR instead.
      img2 = img2.resize(obj_resize, resample=Image.BILINEAR)




.. GENERATED FROM PYTHON SOURCE LINES 70-72

Visualize the images and keypoints


.. GENERATED FROM PYTHON SOURCE LINES 72-87

.. code-block:: default

    def plot_image_with_graph(img, kpt, A=None):
        plt.imshow(img)
        plt.scatter(kpt[0], kpt[1], c='w', edgecolors='k')
        if A is not None:
            for idx in jt.nonzero(A):
                plt.plot((kpt[0, idx[0]], kpt[0, idx[1]]), (kpt[1, idx[0]], kpt[1, idx[1]]), 'k-')

    plt.figure(figsize=(8, 4))
    plt.subplot(1, 2, 1)
    plt.title('Image 1')
    plot_image_with_graph(img1, kpts1)
    plt.subplot(1, 2, 2)
    plt.title('Image 2')
    plot_image_with_graph(img2, kpts2)




.. image-sg:: /auto_examples/jittor/images/sphx_glr_plot_deep_image_matching_001.png
   :alt: Image 1, Image 2
   :srcset: /auto_examples/jittor/images/sphx_glr_plot_deep_image_matching_001.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 88-93

Build the graphs
^^^^^^^^^^^^^^^^^
Graph structures are built based on the geometric structure of the keypoint set. In this example,
we refer to `Delaunay triangulation <https://en.wikipedia.org/wiki/Delaunay_triangulation>`_.


.. GENERATED FROM PYTHON SOURCE LINES 93-104

.. code-block:: default

    def delaunay_triangulation(kpt):
        d = spa.Delaunay(kpt.numpy().transpose())
        A = jt.zeros((len(kpt[0]), len(kpt[0])))
        for simplex in d.simplices:
            for pair in itertools.permutations(simplex, 2):
                A[pair] = 1
        return A

    A1 = delaunay_triangulation(kpts1)
    A2 = delaunay_triangulation(kpts2)








.. GENERATED FROM PYTHON SOURCE LINES 105-107

Visualize the graphs


.. GENERATED FROM PYTHON SOURCE LINES 107-115

.. code-block:: default

    plt.figure(figsize=(8, 4))
    plt.subplot(1, 2, 1)
    plt.title('Image 1 with Graphs')
    plot_image_with_graph(img1, kpts1, A1)
    plt.subplot(1, 2, 2)
    plt.title('Image 2 with Graphs')
    plot_image_with_graph(img2, kpts2, A2)




.. image-sg:: /auto_examples/jittor/images/sphx_glr_plot_deep_image_matching_002.png
   :alt: Image 1 with Graphs, Image 2 with Graphs
   :srcset: /auto_examples/jittor/images/sphx_glr_plot_deep_image_matching_002.png
   :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    /home/roger/.local/lib/python3.8/site-packages/numpy/core/shape_base.py:65: FutureWarning: The input object of type 'jittor_core.Var' is an array-like implementing one of the corresponding protocols (`__array__`, `__array_interface__` or `__array_struct__`); but not a sequence (or 0-D). In the future, this object will be coerced as if it was first converted using `np.array(obj)`. To retain the old behaviour, you have to either modify the type 'jittor_core.Var', or assign to an empty array created with `np.empty(correct_shape, dtype=object)`.
      ary = asanyarray(ary)
    /home/roger/.local/lib/python3.8/site-packages/numpy/core/shape_base.py:65: VisibleDeprecationWarning: Creating an ndarray from ragged nested sequences (which is a list-or-tuple of lists-or-tuples-or ndarrays with different lengths or shapes) is deprecated. If you meant to do this, you must specify 'dtype=object' when creating the ndarray.
      ary = asanyarray(ary)




.. GENERATED FROM PYTHON SOURCE LINES 116-126

Extract node features via CNN
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Deep graph matching solvers can be fused with CNN feature extractors, to build an end-to-end learning pipeline.

In this example, let's adopt the deep graph solvers based on matching two individual graphs.
The image features are based on two intermediate layers from the VGG16 CNN model, following
existing deep graph matching papers (such as :func:`~pygmtools.neural_solvers.pca_gm`)

Let's firstly fetch and download the VGG16 model:


.. GENERATED FROM PYTHON SOURCE LINES 126-128

.. code-block:: default

    vgg16_cnn = models.vgg16_bn(True)








.. GENERATED FROM PYTHON SOURCE LINES 129-131

List of layers of VGG16:


.. GENERATED FROM PYTHON SOURCE LINES 131-133

.. code-block:: default

    print(vgg16_cnn.features)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    Sequential(
        0: Conv(3, 64, (3, 3), (1, 1), (1, 1), (1, 1), 1, float32[64,], None, Kw=None, fan=None, i=None, bound=None)
        1: BatchNorm(64, 1e-05, momentum=0.1, affine=True, is_train=True, sync=True)
        2: relu()
        3: Conv(64, 64, (3, 3), (1, 1), (1, 1), (1, 1), 1, float32[64,], None, Kw=None, fan=None, i=None, bound=None)
        4: BatchNorm(64, 1e-05, momentum=0.1, affine=True, is_train=True, sync=True)
        5: relu()
        6: Pool((2, 2), (2, 2), padding=(0, 0), dilation=None, return_indices=None, ceil_mode=False, count_include_pad=False, op=maximum)
        7: Conv(64, 128, (3, 3), (1, 1), (1, 1), (1, 1), 1, float32[128,], None, Kw=None, fan=None, i=None, bound=None)
        8: BatchNorm(128, 1e-05, momentum=0.1, affine=True, is_train=True, sync=True)
        9: relu()
        10: Conv(128, 128, (3, 3), (1, 1), (1, 1), (1, 1), 1, float32[128,], None, Kw=None, fan=None, i=None, bound=None)
        11: BatchNorm(128, 1e-05, momentum=0.1, affine=True, is_train=True, sync=True)
        12: relu()
        13: Pool((2, 2), (2, 2), padding=(0, 0), dilation=None, return_indices=None, ceil_mode=False, count_include_pad=False, op=maximum)
        14: Conv(128, 256, (3, 3), (1, 1), (1, 1), (1, 1), 1, float32[256,], None, Kw=None, fan=None, i=None, bound=None)
        15: BatchNorm(256, 1e-05, momentum=0.1, affine=True, is_train=True, sync=True)
        16: relu()
        17: Conv(256, 256, (3, 3), (1, 1), (1, 1), (1, 1), 1, float32[256,], None, Kw=None, fan=None, i=None, bound=None)
        18: BatchNorm(256, 1e-05, momentum=0.1, affine=True, is_train=True, sync=True)
        19: relu()
        20: Conv(256, 256, (3, 3), (1, 1), (1, 1), (1, 1), 1, float32[256,], None, Kw=None, fan=None, i=None, bound=None)
        21: BatchNorm(256, 1e-05, momentum=0.1, affine=True, is_train=True, sync=True)
        22: relu()
        23: Pool((2, 2), (2, 2), padding=(0, 0), dilation=None, return_indices=None, ceil_mode=False, count_include_pad=False, op=maximum)
        24: Conv(256, 512, (3, 3), (1, 1), (1, 1), (1, 1), 1, float32[512,], None, Kw=None, fan=None, i=None, bound=None)
        25: BatchNorm(512, 1e-05, momentum=0.1, affine=True, is_train=True, sync=True)
        26: relu()
        27: Conv(512, 512, (3, 3), (1, 1), (1, 1), (1, 1), 1, float32[512,], None, Kw=None, fan=None, i=None, bound=None)
        28: BatchNorm(512, 1e-05, momentum=0.1, affine=True, is_train=True, sync=True)
        29: relu()
        30: Conv(512, 512, (3, 3), (1, 1), (1, 1), (1, 1), 1, float32[512,], None, Kw=None, fan=None, i=None, bound=None)
        31: BatchNorm(512, 1e-05, momentum=0.1, affine=True, is_train=True, sync=True)
        32: relu()
        33: Pool((2, 2), (2, 2), padding=(0, 0), dilation=None, return_indices=None, ceil_mode=False, count_include_pad=False, op=maximum)
        34: Conv(512, 512, (3, 3), (1, 1), (1, 1), (1, 1), 1, float32[512,], None, Kw=None, fan=None, i=None, bound=None)
        35: BatchNorm(512, 1e-05, momentum=0.1, affine=True, is_train=True, sync=True)
        36: relu()
        37: Conv(512, 512, (3, 3), (1, 1), (1, 1), (1, 1), 1, float32[512,], None, Kw=None, fan=None, i=None, bound=None)
        38: BatchNorm(512, 1e-05, momentum=0.1, affine=True, is_train=True, sync=True)
        39: relu()
        40: Conv(512, 512, (3, 3), (1, 1), (1, 1), (1, 1), 1, float32[512,], None, Kw=None, fan=None, i=None, bound=None)
        41: BatchNorm(512, 1e-05, momentum=0.1, affine=True, is_train=True, sync=True)
        42: relu()
        43: Pool((2, 2), (2, 2), padding=(0, 0), dilation=None, return_indices=None, ceil_mode=False, count_include_pad=False, op=maximum)
    )




.. GENERATED FROM PYTHON SOURCE LINES 134-137

Let's define the CNN feature extractor, which outputs the features of ``layer (30)`` and
``layer (37)``


.. GENERATED FROM PYTHON SOURCE LINES 137-149

.. code-block:: default

    class CNNNet(jt.nn.Module):
        def __init__(self, vgg16_module):
            super(CNNNet, self).__init__()
            # The naming of the layers follow ThinkMatch convention to load pretrained models.
            self.node_layers = jt.nn.Sequential(*[_ for _ in list(vgg16_module.features)[:31]])
            self.edge_layers = jt.nn.Sequential(*[_ for _ in list(vgg16_module.features)[31:38]])

        def execute(self, inp_img):
            feat_local = self.node_layers(inp_img)
            feat_global = self.edge_layers(feat_local)
            return feat_local, feat_global








.. GENERATED FROM PYTHON SOURCE LINES 150-153

Download pretrained CNN weights (from `ThinkMatch <https://github.com/Thinklab-SJTU/ThinkMatch>`_),
load the weights and then extract the CNN features


.. GENERATED FROM PYTHON SOURCE LINES 153-161

.. code-block:: default

    cnn = CNNNet(vgg16_cnn)
    path = pygm.utils.download('vgg16_pca_voc_jittor.pt', 'https://drive.google.com/u/0/uc?export=download&confirm=Z-AR&id=1qLxjcVq7X3brylxRJvELCbtCzfuXQ24J')
    cnn.load_state_dict(jt.load(path))

    with jt.no_grad():
        feat1_local, feat1_global = cnn(jittor_img1)
        feat2_local, feat2_global = cnn(jittor_img2)








.. GENERATED FROM PYTHON SOURCE LINES 162-164

Normalize the features


.. GENERATED FROM PYTHON SOURCE LINES 164-198

.. code-block:: default


    def local_response_norm(input: Var, size: int, alpha: float = 1e-4, beta: float = 0.75, k: float = 1.0) -> Var:
        """
        jittor implementation of local_response_norm
        """
        dim = input.ndim
        assert dim >= 3

        if input.numel() == 0:
            return input

        div = input.multiply(input).unsqueeze(1)
        if dim == 3:
            div = nn.pad(div, (0, 0, size // 2, (size - 1) // 2))
            div = nn.avg_pool2d(div, (size, 1), stride=1).squeeze(1)
        else:
            sizes = input.size()
            div = div.view(sizes[0], 1, sizes[1], sizes[2], -1)
            div = nn.pad(div, (0, 0, 0, 0, size // 2, (size - 1) // 2))
            div = nn.AvgPool3d((size, 1, 1), stride=1)(div).squeeze(1)
            div = div.view(sizes)
        div = div.multiply(alpha).add(k).pow(beta)
        return input / div


    def l2norm(node_feat):
        return local_response_norm(
            node_feat, node_feat.shape[1] * 2, alpha=node_feat.shape[1] * 2, beta=0.5, k=0)

    feat1_local = l2norm(feat1_local)
    feat1_global = l2norm(feat1_global)
    feat2_local = l2norm(feat2_local)
    feat2_global = l2norm(feat2_global)








.. GENERATED FROM PYTHON SOURCE LINES 199-201

Up-sample the features to the original image size and concatenate


.. GENERATED FROM PYTHON SOURCE LINES 201-209

.. code-block:: default

    feat1_local_upsample = jt.nn.interpolate(feat1_local, obj_resize, mode='bilinear')
    feat1_global_upsample = jt.nn.interpolate(feat1_global, obj_resize, mode='bilinear')
    feat2_local_upsample = jt.nn.interpolate(feat2_local, obj_resize, mode='bilinear')
    feat2_global_upsample = jt.nn.interpolate(feat2_global, obj_resize, mode='bilinear')
    feat1_upsample = jt.concat((feat1_local_upsample, feat1_global_upsample), dim=1)
    feat2_upsample = jt.concat((feat2_local_upsample, feat2_global_upsample), dim=1)
    num_features = feat1_upsample.shape[1]








.. GENERATED FROM PYTHON SOURCE LINES 210-212

Visualize the extracted CNN feature (dimensionality reduction via principle component analysis)


.. GENERATED FROM PYTHON SOURCE LINES 212-233

.. code-block:: default

    pca_dim_reduc = PCAdimReduc(n_components=3, whiten=True)
    feat_dim_reduc = pca_dim_reduc.fit_transform(
        np.concatenate((
            feat1_upsample.permute(0, 2, 3, 1).reshape(-1, num_features).numpy(),
            feat2_upsample.permute(0, 2, 3, 1).reshape(-1, num_features).numpy()
        ), axis=0)
    )
    feat_dim_reduc = feat_dim_reduc / np.max(np.abs(feat_dim_reduc), axis=0, keepdims=True) / 2 + 0.5
    feat1_dim_reduc = feat_dim_reduc[:obj_resize[0] * obj_resize[1], :]
    feat2_dim_reduc = feat_dim_reduc[obj_resize[0] * obj_resize[1]:, :]

    plt.figure(figsize=(8, 4))
    plt.subplot(1, 2, 1)
    plt.title('Image 1 with CNN features')
    plot_image_with_graph(img1, kpts1, A1)
    plt.imshow(feat1_dim_reduc.reshape(obj_resize[0], obj_resize[1], 3), alpha=0.5)
    plt.subplot(1, 2, 2)
    plt.title('Image 2 with CNN features')
    plot_image_with_graph(img2, kpts2, A2)
    plt.imshow(feat2_dim_reduc.reshape(obj_resize[0], obj_resize[1], 3), alpha=0.5)




.. image-sg:: /auto_examples/jittor/images/sphx_glr_plot_deep_image_matching_003.png
   :alt: Image 1 with CNN features, Image 2 with CNN features
   :srcset: /auto_examples/jittor/images/sphx_glr_plot_deep_image_matching_003.png
   :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    /home/roger/.local/lib/python3.8/site-packages/numpy/core/shape_base.py:65: FutureWarning: The input object of type 'jittor_core.Var' is an array-like implementing one of the corresponding protocols (`__array__`, `__array_interface__` or `__array_struct__`); but not a sequence (or 0-D). In the future, this object will be coerced as if it was first converted using `np.array(obj)`. To retain the old behaviour, you have to either modify the type 'jittor_core.Var', or assign to an empty array created with `np.empty(correct_shape, dtype=object)`.
      ary = asanyarray(ary)
    /home/roger/.local/lib/python3.8/site-packages/numpy/core/shape_base.py:65: VisibleDeprecationWarning: Creating an ndarray from ragged nested sequences (which is a list-or-tuple of lists-or-tuples-or ndarrays with different lengths or shapes) is deprecated. If you meant to do this, you must specify 'dtype=object' when creating the ndarray.
      ary = asanyarray(ary)

    <matplotlib.image.AxesImage object at 0x7f0ee3af40a0>



.. GENERATED FROM PYTHON SOURCE LINES 234-236

Extract node features by nearest interpolation


.. GENERATED FROM PYTHON SOURCE LINES 236-241

.. code-block:: default

    rounded_kpts1 = jt.round(kpts1).long()
    rounded_kpts2 = jt.round(kpts2).long()
    node1 = feat1_upsample[0, :, rounded_kpts1[1], rounded_kpts1[0]].t() # shape: NxC
    node2 = feat2_upsample[0, :, rounded_kpts2[1], rounded_kpts2[0]].t() # shape: NxC








.. GENERATED FROM PYTHON SOURCE LINES 242-246

Call PCA-GM matching model
^^^^^^^^^^^^^^^^^^^^^^^^^^
See :func:`~pygmtools.neural_solvers.pca_gm` for the API reference.


.. GENERATED FROM PYTHON SOURCE LINES 246-263

.. code-block:: default

    X = pygm.pca_gm(node1, node2, A1, A2, pretrain='voc')
    X = pygm.hungarian(X)

    plt.figure(figsize=(8, 4))
    plt.suptitle('Image Matching Result by PCA-GM')
    ax1 = plt.subplot(1, 2, 1)
    plot_image_with_graph(img1, kpts1, A1)
    ax2 = plt.subplot(1, 2, 2)
    plot_image_with_graph(img2, kpts2, A2)
    idx, _ = jt.argmax(X, dim=1)
    for i in range(X.shape[0]):
        j = idx[i].item()
        con = ConnectionPatch(xyA=kpts1[:, i], xyB=kpts2[:, j], coordsA="data", coordsB="data",
                              axesA=ax1, axesB=ax2, color="red" if i != j else "green")
        plt.gca().add_artist(con)





.. image-sg:: /auto_examples/jittor/images/sphx_glr_plot_deep_image_matching_004.png
   :alt: Image Matching Result by PCA-GM
   :srcset: /auto_examples/jittor/images/sphx_glr_plot_deep_image_matching_004.png
   :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    /home/roger/.local/lib/python3.8/site-packages/numpy/core/shape_base.py:65: FutureWarning: The input object of type 'jittor_core.Var' is an array-like implementing one of the corresponding protocols (`__array__`, `__array_interface__` or `__array_struct__`); but not a sequence (or 0-D). In the future, this object will be coerced as if it was first converted using `np.array(obj)`. To retain the old behaviour, you have to either modify the type 'jittor_core.Var', or assign to an empty array created with `np.empty(correct_shape, dtype=object)`.
      ary = asanyarray(ary)
    /home/roger/.local/lib/python3.8/site-packages/numpy/core/shape_base.py:65: VisibleDeprecationWarning: Creating an ndarray from ragged nested sequences (which is a list-or-tuple of lists-or-tuples-or ndarrays with different lengths or shapes) is deprecated. If you meant to do this, you must specify 'dtype=object' when creating the ndarray.
      ary = asanyarray(ary)




.. GENERATED FROM PYTHON SOURCE LINES 264-273

Matching images with other neural networks
-------------------------------------------
The above pipeline also works for other deep graph matching networks. Here we give examples of
:func:`~pygmtoools.neural_solvers.ipca_gm` and :func:`~pygmtoools.neural_solvers.cie`.

Matching by IPCA-GM model
^^^^^^^^^^^^^^^^^^^^^^^^^
See :func:`~pygmtools.neural_solvers.ipca_gm` for the API reference.


.. GENERATED FROM PYTHON SOURCE LINES 273-279

.. code-block:: default

    path = pygm.utils.download('vgg16_ipca_voc_jittor.pt', 'https://drive.google.com/u/0/uc?export=download&confirm=Z-AR&id=1f7KEl9ZFZwI26j6UId-fsdl8Y8QWPKZi')
    cnn.load_state_dict(jt.load(path))

    feat1_local, feat1_global = cnn(jittor_img1)
    feat2_local, feat2_global = cnn(jittor_img2)








.. GENERATED FROM PYTHON SOURCE LINES 280-282

Normalize the features


.. GENERATED FROM PYTHON SOURCE LINES 282-291

.. code-block:: default

    def l2norm(node_feat):
        return local_response_norm(
            node_feat, node_feat.shape[1] * 2, alpha=node_feat.shape[1] * 2, beta=0.5, k=0)

    feat1_local = l2norm(feat1_local)
    feat1_global = l2norm(feat1_global)
    feat2_local = l2norm(feat2_local)
    feat2_global = l2norm(feat2_global)








.. GENERATED FROM PYTHON SOURCE LINES 292-294

Up-sample the features to the original image size and concatenate


.. GENERATED FROM PYTHON SOURCE LINES 294-302

.. code-block:: default

    feat1_local_upsample = jt.nn.interpolate(feat1_local, obj_resize, mode='bilinear')
    feat1_global_upsample = jt.nn.interpolate(feat1_global, obj_resize, mode='bilinear')
    feat2_local_upsample = jt.nn.interpolate(feat2_local, obj_resize, mode='bilinear')
    feat2_global_upsample = jt.nn.interpolate(feat2_global, obj_resize, mode='bilinear')
    feat1_upsample = jt.concat((feat1_local_upsample, feat1_global_upsample), dim=1)
    feat2_upsample = jt.concat((feat2_local_upsample, feat2_global_upsample), dim=1)
    num_features = feat1_upsample.shape[1]








.. GENERATED FROM PYTHON SOURCE LINES 303-305

Extract node features by nearest interpolation


.. GENERATED FROM PYTHON SOURCE LINES 305-310

.. code-block:: default

    rounded_kpts1 = jt.round(kpts1).long()
    rounded_kpts2 = jt.round(kpts2).long()
    node1 = feat1_upsample[0, :, rounded_kpts1[1], rounded_kpts1[0]].t() # shape: NxC
    node2 = feat2_upsample[0, :, rounded_kpts2[1], rounded_kpts2[0]].t() # shape: NxC








.. GENERATED FROM PYTHON SOURCE LINES 311-313

Build edge features as edge lengths


.. GENERATED FROM PYTHON SOURCE LINES 313-321

.. code-block:: default

    kpts1_dis = (kpts1.unsqueeze(0) - kpts1.unsqueeze(1))
    kpts1_dis = jt.norm(kpts1_dis, p=2, dim=2).detach()
    kpts2_dis = (kpts2.unsqueeze(0) - kpts2.unsqueeze(1))
    kpts2_dis = jt.norm(kpts2_dis, p=2, dim=2).detach()

    Q1 = jt.exp(-kpts1_dis / obj_resize[0])
    Q2 = jt.exp(-kpts2_dis / obj_resize[0])








.. GENERATED FROM PYTHON SOURCE LINES 322-324

Matching by IPCA-GM model


.. GENERATED FROM PYTHON SOURCE LINES 324-340

.. code-block:: default

    X = pygm.ipca_gm(node1, node2, A1, A2, pretrain='voc')
    X = pygm.hungarian(X)

    plt.figure(figsize=(8, 4))
    plt.suptitle('Image Matching Result by IPCA-GM')
    ax1 = plt.subplot(1, 2, 1)
    plot_image_with_graph(img1, kpts1, A1)
    ax2 = plt.subplot(1, 2, 2)
    plot_image_with_graph(img2, kpts2, A2)
    idx, _ = jt.argmax(X, dim=1)
    for i in range(X.shape[0]):
        j = idx[i].item()
        con = ConnectionPatch(xyA=kpts1[:, i], xyB=kpts2[:, j], coordsA="data", coordsB="data",
                              axesA=ax1, axesB=ax2, color="red" if i != j else "green")
        plt.gca().add_artist(con)




.. image-sg:: /auto_examples/jittor/images/sphx_glr_plot_deep_image_matching_005.png
   :alt: Image Matching Result by IPCA-GM
   :srcset: /auto_examples/jittor/images/sphx_glr_plot_deep_image_matching_005.png
   :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    /home/roger/.local/lib/python3.8/site-packages/numpy/core/shape_base.py:65: FutureWarning: The input object of type 'jittor_core.Var' is an array-like implementing one of the corresponding protocols (`__array__`, `__array_interface__` or `__array_struct__`); but not a sequence (or 0-D). In the future, this object will be coerced as if it was first converted using `np.array(obj)`. To retain the old behaviour, you have to either modify the type 'jittor_core.Var', or assign to an empty array created with `np.empty(correct_shape, dtype=object)`.
      ary = asanyarray(ary)
    /home/roger/.local/lib/python3.8/site-packages/numpy/core/shape_base.py:65: VisibleDeprecationWarning: Creating an ndarray from ragged nested sequences (which is a list-or-tuple of lists-or-tuples-or ndarrays with different lengths or shapes) is deprecated. If you meant to do this, you must specify 'dtype=object' when creating the ndarray.
      ary = asanyarray(ary)




.. GENERATED FROM PYTHON SOURCE LINES 341-345

Matching by CIE model
^^^^^^^^^^^^^^^^^^^^^^
See :func:`~pygmtools.neural_solvers.cie` for the API reference.


.. GENERATED FROM PYTHON SOURCE LINES 345-351

.. code-block:: default

    path = pygm.utils.download('vgg16_cie_voc_jittor.pt', 'https://drive.google.com/u/0/uc?export=download&confirm=Z-AR&id=1wDbA-8sK4BNhA48z2c-Gtdd4AarRxfqT')
    cnn.load_state_dict(jt.load(path))

    feat1_local, feat1_global = cnn(jittor_img1)
    feat2_local, feat2_global = cnn(jittor_img2)








.. GENERATED FROM PYTHON SOURCE LINES 352-354

Normalize the features


.. GENERATED FROM PYTHON SOURCE LINES 354-363

.. code-block:: default

    def l2norm(node_feat):
        return local_response_norm(
            node_feat, node_feat.shape[1] * 2, alpha=node_feat.shape[1] * 2, beta=0.5, k=0)

    feat1_local = l2norm(feat1_local)
    feat1_global = l2norm(feat1_global)
    feat2_local = l2norm(feat2_local)
    feat2_global = l2norm(feat2_global)








.. GENERATED FROM PYTHON SOURCE LINES 364-366

Up-sample the features to the original image size and concatenate


.. GENERATED FROM PYTHON SOURCE LINES 366-374

.. code-block:: default

    feat1_local_upsample = jt.nn.interpolate(feat1_local, obj_resize, mode='bilinear')
    feat1_global_upsample = jt.nn.interpolate(feat1_global, obj_resize, mode='bilinear')
    feat2_local_upsample = jt.nn.interpolate(feat2_local, obj_resize, mode='bilinear')
    feat2_global_upsample = jt.nn.interpolate(feat2_global, obj_resize, mode='bilinear')
    feat1_upsample = jt.concat((feat1_local_upsample, feat1_global_upsample), dim=1)
    feat2_upsample = jt.concat((feat2_local_upsample, feat2_global_upsample), dim=1)
    num_features = feat1_upsample.shape[1]








.. GENERATED FROM PYTHON SOURCE LINES 375-377

Extract node features by nearest interpolation


.. GENERATED FROM PYTHON SOURCE LINES 377-382

.. code-block:: default

    rounded_kpts1 = jt.round(kpts1).long()
    rounded_kpts2 = jt.round(kpts2).long()
    node1 = feat1_upsample[0, :, rounded_kpts1[1], rounded_kpts1[0]].t() # shape: NxC
    node2 = feat2_upsample[0, :, rounded_kpts2[1], rounded_kpts2[0]].t() # shape: NxC








.. GENERATED FROM PYTHON SOURCE LINES 383-385

Build edge features as edge lengths


.. GENERATED FROM PYTHON SOURCE LINES 385-393

.. code-block:: default

    kpts1_dis = (kpts1.unsqueeze(1) - kpts1.unsqueeze(2))
    kpts1_dis = jt.norm(kpts1_dis, p=2, dim=0).detach()
    kpts2_dis = (kpts2.unsqueeze(1) - kpts2.unsqueeze(2))
    kpts2_dis = jt.norm(kpts2_dis, p=2, dim=0).detach()

    Q1 = jt.exp(-kpts1_dis / obj_resize[0]).unsqueeze(-1).float32()
    Q2 = jt.exp(-kpts2_dis / obj_resize[0]).unsqueeze(-1).float32()








.. GENERATED FROM PYTHON SOURCE LINES 394-396

Call CIE matching model


.. GENERATED FROM PYTHON SOURCE LINES 396-412

.. code-block:: default

    X = pygm.cie(node1, node2, A1, A2, Q1, Q2, pretrain='voc')
    X = pygm.hungarian(X)

    plt.figure(figsize=(8, 4))
    plt.suptitle('Image Matching Result by CIE')
    ax1 = plt.subplot(1, 2, 1)
    plot_image_with_graph(img1, kpts1, A1)
    ax2 = plt.subplot(1, 2, 2)
    plot_image_with_graph(img2, kpts2, A2)
    idx, _ = jt.argmax(X, dim=1)
    for i in range(X.shape[0]):
        j = idx[i].item()
        con = ConnectionPatch(xyA=kpts1[:, i], xyB=kpts2[:, j], coordsA="data", coordsB="data",
                              axesA=ax1, axesB=ax2, color="red" if i != j else "green")
        plt.gca().add_artist(con)




.. image-sg:: /auto_examples/jittor/images/sphx_glr_plot_deep_image_matching_006.png
   :alt: Image Matching Result by CIE
   :srcset: /auto_examples/jittor/images/sphx_glr_plot_deep_image_matching_006.png
   :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    /home/roger/.local/lib/python3.8/site-packages/numpy/core/shape_base.py:65: FutureWarning: The input object of type 'jittor_core.Var' is an array-like implementing one of the corresponding protocols (`__array__`, `__array_interface__` or `__array_struct__`); but not a sequence (or 0-D). In the future, this object will be coerced as if it was first converted using `np.array(obj)`. To retain the old behaviour, you have to either modify the type 'jittor_core.Var', or assign to an empty array created with `np.empty(correct_shape, dtype=object)`.
      ary = asanyarray(ary)
    /home/roger/.local/lib/python3.8/site-packages/numpy/core/shape_base.py:65: VisibleDeprecationWarning: Creating an ndarray from ragged nested sequences (which is a list-or-tuple of lists-or-tuples-or ndarrays with different lengths or shapes) is deprecated. If you meant to do this, you must specify 'dtype=object' when creating the ndarray.
      ary = asanyarray(ary)




.. GENERATED FROM PYTHON SOURCE LINES 413-429

Training a deep graph matching model
-------------------------------------
In this section, we show how to build a deep graph matching model which supports end-to-end training.
For the image matching problem considered here, the model is composed of a CNN feature extractor and
a learnable matching module. Take the PCA-GM model as an example.

.. note::
    This simple example is intended to show you how to do the basic execute and backward pass when
    training an end-to-end deep graph matching neural network. A 'more formal' deep learning pipeline
    should involve asynchronized data loader, batched operations, CUDA support and so on, which are
    all omitted in consideration of simplicity. You may refer to `ThinkMatch <https://github.com/Thinklab-SJTU/ThinkMatch>`_
    which is a research protocol with all these advanced features.

Let's firstly define the neural network model. By calling :func:`~pygmtools.utils.get_network`,
it will simply return the network object.


.. GENERATED FROM PYTHON SOURCE LINES 429-464

.. code-block:: default

    class GMNet(jt.nn.Module):
        def __init__(self):
            super(GMNet, self).__init__()
            self.gm_net = pygm.utils.get_network(pygm.pca_gm, pretrain=False) # fetch the network object
            self.cnn = CNNNet(vgg16_cnn)

        def execute(self, img1, img2, kpts1, kpts2, A1, A2):
            # CNN feature extractor layers
            feat1_local, feat1_global = self.cnn(img1)
            feat2_local, feat2_global = self.cnn(img2)
            feat1_local = l2norm(feat1_local)
            feat1_global = l2norm(feat1_global)
            feat2_local = l2norm(feat2_local)
            feat2_global = l2norm(feat2_global)

            # upsample feature map
            feat1_local_upsample = jt.nn.interpolate(feat1_local, obj_resize, mode='bilinear')
            feat1_global_upsample = jt.nn.interpolate(feat1_global, obj_resize, mode='bilinear')
            feat2_local_upsample = jt.nn.interpolate(feat2_local, obj_resize, mode='bilinear')
            feat2_global_upsample = jt.nn.interpolate(feat2_global, obj_resize, mode='bilinear')
            feat1_upsample = jt.concat((feat1_local_upsample, feat1_global_upsample), dim=1)
            feat2_upsample = jt.concat((feat2_local_upsample, feat2_global_upsample), dim=1)

            # assign node features
            rounded_kpts1 = jt.round(kpts1).long()
            rounded_kpts2 = jt.round(kpts2).long()
            node1 = feat1_upsample[0, :, rounded_kpts1[1], rounded_kpts1[0]].t()  # shape: NxC
            node2 = feat2_upsample[0, :, rounded_kpts2[1], rounded_kpts2[0]].t()  # shape: NxC

            # PCA-GM matching layers
            X = pygm.pca_gm(node1, node2, A1, A2, network=self.gm_net) # the network object is reused
            return X

    model = GMNet()








.. GENERATED FROM PYTHON SOURCE LINES 465-468

Define optimizer
^^^^^^^^^^^^^^^^^


.. GENERATED FROM PYTHON SOURCE LINES 468-470

.. code-block:: default

    optim = jt.optim.Adam(model.parameters(), lr=1e-3)








.. GENERATED FROM PYTHON SOURCE LINES 471-474

Forward pass
^^^^^^^^^^^^^


.. GENERATED FROM PYTHON SOURCE LINES 474-476

.. code-block:: default

    X = model(jittor_img1, jittor_img2, kpts1, kpts2, A1, A2)








.. GENERATED FROM PYTHON SOURCE LINES 477-482

Compute loss
^^^^^^^^^^^^^
In this example, the ground truth matching matrix is a diagonal matrix. We calculate the loss function via
:func:`~pygmtools.utils.permutation_loss`


.. GENERATED FROM PYTHON SOURCE LINES 482-486

.. code-block:: default

    X_gt = jt.init.eye(X.shape[0])
    loss = pygm.utils.permutation_loss(X, X_gt)
    print(f'loss={loss:.4f}')





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    loss=2.9705




.. GENERATED FROM PYTHON SOURCE LINES 487-490

Backward Pass
^^^^^^^^^^^^^^


.. GENERATED FROM PYTHON SOURCE LINES 490-492

.. code-block:: default

    optim.backward(loss)








.. GENERATED FROM PYTHON SOURCE LINES 493-495

Visualize the gradients


.. GENERATED FROM PYTHON SOURCE LINES 495-505

.. code-block:: default

    plt.figure(figsize=(4, 4))
    plt.title('Gradient Sizes of PCA-GM and VGG16 layers')
    plt.gca().set_xlabel('Layer Index')
    plt.gca().set_ylabel('Average Gradient Size')
    grad_size = []
    for param in model.parameters():
        grad_size.append(jt.abs(param.opt_grad(optim)).mean().item())
    print(grad_size)
    plt.stem(grad_size)




.. image-sg:: /auto_examples/jittor/images/sphx_glr_plot_deep_image_matching_007.png
   :alt: Gradient Sizes of PCA-GM and VGG16 layers
   :srcset: /auto_examples/jittor/images/sphx_glr_plot_deep_image_matching_007.png
   :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    [0.00012008137855445966, 0.0029865035321563482, 0.00018511232337914407, 0.0033753272145986557, 0.0002137543197022751, 0.005234790500253439, 9.73292117123492e-06, 4.477985203266144e-05, 9.332987247034907e-05, 0.0038247969932854176, 0.00013548837159760296, 0.002944774692878127, 0.0005545496242120862, 1.8891434194756584e-08, 0.0010682500433176756, 0.0005676004802808166, 0.0, 0.0, 0.00017916866636369377, 8.408768792378396e-09, 0.0021129779051989317, 0.0012607568642124534, 0.0, 0.0, 0.0002507281315047294, 3.2628841850623758e-09, 0.0015229436103254557, 0.0010184939019382, 0.0, 0.0, 0.00021608102542813867, 4.296822453397908e-09, 0.002223665826022625, 0.0010056477040052414, 0.0, 0.0, 0.0002108924527419731, 1.4684102822570821e-09, 0.0016412498662248254, 0.0010497840121388435, 0.0, 0.0, 0.0001778988225851208, 2.4535937726000157e-09, 0.0017658978467807174, 0.001085389405488968, 0.0, 0.0, 0.00018341925169806927, 3.0536160267047308e-09, 0.0021165432408452034, 0.001017216476611793, 0.0, 0.0, 0.0001568129227962345, 7.326517170724856e-10, 0.0017438650829717517, 0.001043159980326891, 0.0, 0.0, 0.00012114781566197053, 1.4319967434062164e-09, 0.001918911118991673, 0.001163581619039178, 0.0, 0.0, 0.00011734791769413278, 0.0005073942593298852, 0.0016806223429739475, 0.0008340583881363273, 0.0, 0.0, 8.978342521004379e-05, 4.2901138197493083e-10, 0.001494081923738122, 0.0009877857519313693, 0.0, 0.0, 8.40352731756866e-05, 0.000910142669454217]

    <StemContainer object of 3 artists>



.. GENERATED FROM PYTHON SOURCE LINES 506-509

Update the model parameters. A deep learning pipeline should iterate the forward pass
and backward pass steps until convergence.


.. GENERATED FROM PYTHON SOURCE LINES 509-512

.. code-block:: default

    optim.step()
    optim.zero_grad()








.. GENERATED FROM PYTHON SOURCE LINES 513-517

.. note::
    This example supports both GPU and CPU, and the online documentation is built by a CPU-only machine.
    The efficiency will be significantly improved if you run this code on GPU.



.. rst-class:: sphx-glr-timing

   **Total running time of the script:** ( 5 minutes  36.198 seconds)


.. _sphx_glr_download_auto_examples_jittor_plot_deep_image_matching.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example


    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: plot_deep_image_matching.py <plot_deep_image_matching.py>`

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: plot_deep_image_matching.ipynb <plot_deep_image_matching.ipynb>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
